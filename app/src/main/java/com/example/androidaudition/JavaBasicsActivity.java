package com.example.androidaudition;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.provider.CalendarContract;
import android.util.Log;
import android.view.View;

import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;

public class JavaBasicsActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_java_basics);

        /**
         * 1.java中==和equals和hashCode的区别：
         *      1. == ： 该操作符生成的是一个boolean结果，它计算的是操作数的值之间的关系，即：基本类型比较值，引用类型比较内存地址
         *          1.1 操作数的值：
         *              1.1.1 基本数据类型变量：
         *                  浮点型：float(4 byte), double(8 byte)
         *                  整型：byte(1 byte), short(2 byte), int(4 byte) , long(8 byte)
         *                  字符型: char(2 byte)
         *                  布尔型: boolean(JVM规范没有明确规定其所占的空间大小，仅规定其只能够取字面值”true”和”false”)
         *                  对于这八种基本数据类型的变量，变量直接存储的是“值”。因此，在使用关系操作符 == 来进行比较时，比较的就是“值”本身。
         *              1.1.2 引用类型：
         *                  引用类型的变量存储的并不是“值”本身，而是与其关联的对象在内存中的地址
         *          1.2：例子见 fun_1_1
         *
         *      2. equals ： Object 的 实例方法，比较两个对象的content是否相同
         *          2.1 在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。
         *          2.2 String 重写了 equals 方法。见String 中的方法。比较字符的个数，和对应位数的字符是否相等。
         *          2.3 总结：equals方法
         *              先 比较引用是否相同(是否为同一对象)(object 中的equals方法)
         *              再 判断类型是否一致（是否为同一类型）,（子类重写 比如 Integer）
         *              最后 比较内容是否一致 （子类重写，比如 Integer）
         *          2.4 equals 重写原则：（对象内容的比较才是设计equals()的真正目的）
         *              - 对称性： 如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”
         *              - 自反性： x.equals(x)必须返回是“true”
         *              - 类推性： 如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”
         *              - 一致性： 如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”
         *              - 任何情况下，x.equals(null)【应使用关系比较符 ==】，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”
         *
         *
         *      3. hashCode ： Object 的 native方法 , 获取对象的哈希值，用于确定该对象在哈希表中的索引位置，它实际上是一个int型整数
         *          3.1 哈希相关概念
         *              3.1.1 概念 ：
         *                  Hash 就是把任意长度的输入(又叫做预映射， pre-image)，通过散列算法，变换成固定长度的输出(int)，
         *                  该输出就是散列值。这种转换是一种 压缩映射，也就是说，散列值的空间通常远小于输入的空间。
         *                  不同的输入可能会散列成相同的输出，从而不可能从散列值来唯一的确定输入值。
         *                  简单的说，就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
         *              3.1.2 应用–数据结构 ：
         *                  数组的特点是：寻址容易，插入和删除困难; 而链表的特点是：寻址困难，插入和删除容易。
         *                  那么我们能不能综合两者的特性，做出一种寻址容易，插入和删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，
         *                  哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为 “链表的数组”
         *                  将根据元素特征计算元素数组下标的方法就是散列法。
         *                  拉链法的适用范围 ： 快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。
         *          3.2 hashCode 简述 （在 Java 中，由 Object 类定义的 hashCode 方法会针对不同的对象返回不同的整数。
         *                             （这是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧）。）
         *              3.2.1 hashCode 的常规协定是
         *                  - 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，
         *                    前提是将对象进行 equals 比较时所用的信息没有被修改
         *                  - 如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。
         *                  - 如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法
         *                    不要求 一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。
         *                  - hash表存入值得方法（步骤）
         *                      - 先调用这个元素的 hashCode 方法，然后根据所得到的值计算出元素应该在数组的位置。如果这个位置上没有元素，
         *                        那么直接将它存储在这个位置上；
         *                      - 如果这个位置上已经有元素了，那么调用它的equals方法与新元素进行比较：相同的话就不存了，
         *                        否则，将其存在这个位置对应的链表中（Java 中 HashSet, HashMap 和 Hashtable的实现总将元素放到链表的表头）。
         *      4.总结：
         *          - hashcode是系统用来快速检索对象而使用
         *          - equals方法本意是用来判断引用的对象是否一致
         *          - 重写equals方法和hashcode方法时，equals方法中用到的成员变量也必定会在hashcode方法中用到,只不过前者作为比较项，
         *          后者作为生成摘要的信息项，本质上所用到的数据是一样的，从而保证二者的一致性
         *
         */

        /**
         *  2.Java中的四种引用方式(强引用、软引用、弱引用、虚引用)
         *      1 强引用（StrongReference）
         *          1.1 强引用就是指在程序代码之中普遍存在的 比如 Object obj = new Object();
         *              - 只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象
         *              - 如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象
         *      2 软引用（SoftReference）
         *          2.1 软引用是用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示
         *              - 对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象
         *              - 因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。
         *              - 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中
         *              - 例子见 fun_2_2
         *      3 弱引用（WeakReference）
         *          3.1 弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
         *              - 在java中，用java.lang.ref.WeakReference类来表示 使用方式和软引用一样
         *      4 虚引用（PhantomReference）
         *              - 虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期
         *              - 在java中用java.lang.ref.PhantomReference类表示
         *              - 如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。
         */

        /**
         * 3.int与integer的区别
         *      - Integer是int的包装类；int是基本数据类型；
         *      - Integer变量必须实例化后才能使用；int变量不需要；
         *      - Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；
         *      - Integer的默认值是null；int的默认值是0。
         *      - 泛型不支持int，但是支持Integer
         *      - int 存储在栈中，Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。
         *      1.自动装箱和自动拆箱(8种基本类型才有)
         *          1.1 自动装箱：将基本数据类型重新转化为对象： Integer num = 1;
         *          1.2 自动拆箱：将对象重新转化为基本数据类型： Integer integer = 1; int a = integer+5;
         *          1.3 相同值下的 int 和 Integer 的比较结果 见例子 fun_3_1_1
         *              - 两个通过new生成的变量,是创建两个对象的比较
         *              - int 和 Integer 的值比较,Integer会自动拆箱为int类型，然后再做比较，实际上就变为两个int变量的比较
         *              - new 生成的Integer变量 和 非new 生成的Integer变量比较，new 生成的Integer变量的值在堆空间中，
         *                非new 生成的Integer变量的值在在常量池中
         *              - 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，
         *                如果两个变量的值不在此区间，则比较结果为false
         *              - 非new生成的Integer变量，会先判断常量池中是否有该对象，若有则共享，若无则在常量池中放入该对象；这也叫享元模式
         */

        /**
         *  4 进制
         *      4.1 基本概念 0b10011001 (0b开头表示二进制)
         *          - 数码：值这个数据的每一位的数字
         *          - 数位：数码在这个数中的位置，从右到左，依次递增，从0开始
         *          - 基数：每一个数码可以有多少个数据表示（其实就是指这个数的进制）
         *          - 位权： 数码 * （基数的数位次方）
         *      4.2 进制转换：
         *          4.2.1 十进制与二进制转换：
         *              - 10进制转2进制：除以2取余，直到余数是1或者0，然后将余数倒序就是十进制对应的二进制
         *              - 2进制转10进制：加权法，将二进制数的没个数码的位权相加
         *          4.2.2 十进制于八进制转换
         *          - 10进制转8进制：除以8取余
         *          - 8进制转10进制：加权法，和2进制相似
         *          4.2.3 二进制和八进制的转换
         *              - 二进制转八进制：三合一法则，将这个二进制从低位到高位（左高，右低）每三位分成1组，高位不够补0，将每组转换转为8进制
         *                然后将每一组的八进制连起来。
         *              - 8进制转2进制：一拆三，将八进制数的每一个数码拆分为一个三位的二进制，然后连起来
         *          4.2.4 二进制和十六进制的转换
         *              - 二进制转十六进制：四合一法则，参考三合一
         *              - 十六进制转二进制：一拆四法则，参考一拆三
         */

        /**
         *
         *  5 原码，反码，补码 和运算
         *      - 无论任何数据，在内存中存储的时候都是以二进制的形式存储的，
         *        原码，反码，补码都是二进制，只不过是二进制的不同表现形式，数据是以补码的二进制存储的。
         *      5.1 以int为例 ：4字节 32位
         *          00000000 00000000 00000000 00000000
         *          为了表示正负，使用最高位表示正负 0表示正，1表示负
         *          int，表示数据只有31位
         *      5.2 原码：
         *          最高位表示符号位，剩下的位数，是这个数的绝对值的二进制
         *          10 的原码：
         *          00000000 0000000 00000000 00001010
         *          -8 的原码：
         *          10000000 0000000 00000000 00001000
         *      5.3 反码：
         *          - 正数的反码，是其原码
         *          - 负数的原码，是其原码基础上，符号位不变，其他位取反
         *          10的反码：
         *          00000000 00000000 00000000 00001010
         *          -8的反码：
         *          11111111 11111111 11111111 11110111
         *      5.4 补码：
         *          - 正数的补码，就是其原码
         *          - 负数的补码，就是在其反码基础上+1
         *      5.5 按位与运算 &
         *          - 指的是1个二进制数据的每一位参与运算，
         *          - 参与位运算的二进制必须是补码形式
         *          - 运算的结果也是二进制的补码形式
         *          - 同位，均为1，结果为1，否则为0.
         *          00000000 00000000 00000000 00000001
         *          00000000 00000000 00000000 00001001
         *          结果为
         *          00000000 00000000 00000000 00000001
         *          - 在判断一个数的奇偶时，可以使用 （x&1）== 0
         *      5.6 按位或 |
         *          - 参与二进制的数据，只要有一位是1结果就为1 （依然是补码形式）
         *            00000000 00000000 00000000 00000001
         *            00000000 00000000 00000000 00001001
         *            结果为
         *            00000000 00000000 00000000 00001001
         *      5.7 按位取反 ~
         *          - 单目运算，将二进制每一位取反（包含符号位，依然是补码形式）
         *      5.8 按位异或 ^
         *          - 参与的数据，如果相同为0，不同为1
         *          使用： 交换两个数据
         *          a = a^b;b = a^b;a=a^b;
         *      5.9 按位 左移，右移
         *          - 左移：向左移动指定位置，低位不够补0，高位溢出丢掉
         *              - 左移运算可能改变正负
         *              - 将数左移n位，相当于，这个数 * 2的n次方
         *          - 向右移动指定位置，低位溢出丢掉，高位补符号位（原来是0，就补0 ，原来是1，就补1）。
         *              - 右移不会改变正负
         *              - 将数右移，相当于，这个数 除以 2的n次方
         *
         */

        /**
         *  6.java多态
         *      - 多态是同一个行为具有多个不同的表现形式
         *      - 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。
         *        多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。
         *      6.1 多态的优点
         *          - 消除类型之间的耦合关系
         *          - 可替换性
         *          - 可扩展性
         *          - 接口性
         *          - 灵活性
         *          - 简化性
         *      6.2 多态存在的必要条件
         *          - 继承
         *          - 重写
         *          - 父类引用指向子类引用 （ Father f = new Child(); ）
         *      6.3 虚函数
         *          - 虚函数的存在是为了多态。
         *          - Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。
         *            如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。
         *      6.4 多态的实现方式
         *          - 重写
         *          - 接口
         *          - 抽象类和抽象方法
         *
         */

        /**
         *  7.String、StringBuffer、StringBuilder区别
         *      7.1 String: 字符串常量,String类是不可变类，任何对String的改变都 会引发新的String对象的生成
         *      7.2 StringBuffer 字符串变量（线程安全）
         *      7.3 StringBuilder 字符串变量（非线程安全）
         */

        /**
         *  8. JAVA 内部类
         *      8.1 内部类为什么存在
         *          - 内部类（inner class）：定义在另一个类中的类
         *          - 内部类的特点：
         *              - 内部类方法可以访问改定义所在作用域中的数据，包括被private修饰的私有数据（内部类可以访问外部类所以方法和属性见A类）
         *              - 内部类可以对同一包中的其他类隐藏（安全）
         *              - 内部类可以实现java单继承的缺陷
         *              - 当我们想定义一个回调函数，缺不想写大量代码的时候，可以使用匿名内部类实现
         *      8.2 内部类与外部类的关系
         *          - 对于非静态内部类，内部类的创建依赖外部类的实例对象，在没有外部类对象实例之前无法创建内部类
         *          - 内部类是一个相对独立的实体，与外部类不是 is -a 关系
         *          - 创建内部类的时刻并不依赖于外部类的创建
         *      8.3 内部类的分类
         *          - 静态内部类（嵌套类）
         *          - 非静态内部类
         *              - 成员内部类
         *              - 方法内部类（局部内部类）
         *                  - 如果一个内部类只有一个方法中使用到了，那么我们可以将这个定义在方法内部，
         *                      这种内部类就被称为局部内部类，作用域，仅限于该方法
         *                  - 注意：
         *                      - 局部内部类不允许使用权限修饰符(比如 void fun(){ public Class C{} })，不被允许
         *                      - 局部内部类对外完全隐藏，除了创建类的方法可以访问，其他不允许访问
         *                      - 局部内部类与成员内部类不同之处，是他可以引用成员变量，但该成员必须声明为final
         *              - 匿名内部类
         *                  - 匿名内部类是没有访问修饰符的。
         *                  - 匿名内部类必须继承一个抽象类或者实现一个接口
         *                  - 匿名内部类中不能存在任何静态成员或方法
         *                  - 匿名内部类是没有构造方法的，因为它没有类名。
         *                  - 与局部内部相同匿名内部类也可以引用局部变量。此变量也必须声明为 final
         *      8.4 静态内部类，可能会引起内存泄漏：
         *          - 如果当内部类的引用被外部类以外的其他类引用时，就会造成内部类和外部类无法被GC回收的情况，
         *            即使外部类没有被引用，因为内部类持有指向外部类的引用）
         *          - 可以采用弱引用的方式 ，来持有外部类对象
         *
         */

        /**
         *  9 抽象类和接口
         *      9.1 什么是抽象类和接口
         *          9.1.1 抽象类
         *              - abstract 修饰的类
         *              - 抽象类的特点：
         *                  - 抽象类，不允许直接实例化
         *                  - 抽象类，通常作为父类
         *                  - 抽象方法必须是public或者protected，缺省情况下，默认是public
         *                  - 抽象方法，必须由子类实现
         *                  - 如果一个类继承抽象类，则子类必须实现抽象方法，或者子类也为抽象类
         *                  - 抽象类还是很重要的重构工具，因为它们使得我们很容易地将公共方法沿着继承结构向上移动
         *          9.1.2 接口
         *              - 接口 是抽象类的特殊形式，使用interface修饰
         *              - 接口的特点：
         *                  - 接口所有方法的访问权限均为public
         *                  - 接口中定义的成员变量，会自动变为 public static final 修饰的静态常亮
         *                  - 实现接口的非抽象类必须实现接口所有方法，抽象类可以部分实现
         *                  - 接口不能直接创建对象，但可以申明一个接口变量，方便调用
         *                  - 完全解耦，可以编写可复用性更好的代码
         *       9.2 接口和抽象类的不同
         *          - 抽象层次不同
         *              - 抽象类是对类抽象，接口是对行为抽象
         *              - 抽象类是对整个类整体进行抽象，包括属性，行为，但接口却是对类局部行为进行抽象
         *          - 跨域不同
         *              - 抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类
         *              - 抽象类所体现的一种继承关系，考虑的是子类和父类本质"是不是"同一类的关系
         *              - 接口不要求实现类和接口是同一本质，它们之间只存在"有没有这个能力"的关系
         *          - 设计层次不同
         *              - 抽象类是自下而上的设计，子类中重复出现的工作，抽象到抽象类中
         *              - 接口是自上而下，定义行为和规范
         *       9.3 如何选择抽象类还是接口
         *          - 只有必须使用方法定义或者成员变量的时候，才考虑使用抽象类
         *          - 其他情况，都应该优先使用接口。接口可以多实现，更灵活，抽象类，只能单继承。
         *
         *
         */

        /**
         *  10 java泛型
         *      10.1 泛型是什么
         *          - List<String> list=new ArrayList<>();
         *          - ArrayList 就是一个泛型。泛型，就是泛指的意思。设定一个数据类型，避免出现运行时数据转型错误。
         *      10.2 泛型介绍
         *          10.2.1 java泛型类
         *              - 类结构是面向对象中最基本的元素，如果我们需要类具有很好的扩展性，那么我们可以将其设置为泛型的
         *              - 见类 DataHolder
         *          10.2.2 java泛型方法
         *              - 如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法
         *              - 见 DataHolder
         *              - 泛型方法的基本特征：
         *                  - public 和 返回值中间（<T>）非常重要,可以理解为声明此方法为泛型方法： public <T> void xx(T t){}
         *                  - 只要声明了的方法才是泛型方法，泛型类中的使用泛型的成员方法并不是泛型方法
         *                  - 表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T
         *                  - 与泛型类的定义一样，此时T可以随便写为任意标识，常见的如T,E,K等形式
         *          10.2.3 java泛型接口
         *          10.2.4 java泛型擦除及相关内容
         *          10.2.5 java泛型通配符（extends 和 supper）
         */


        findViewById(R.id.btn_fun_1_1).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                fun_1_1();
            }
        });
        findViewById(R.id.btn_fun_2_2).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                fun_2_2();
            }
        });
        findViewById(R.id.btn_fun_3_1).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                fun_3_1();
            }
        });
    }

    void fun_3_1() {
        Integer i1 = new Integer(3);
        Integer i2 = new Integer(3);
        Integer i3 = Integer.valueOf(3);
        Integer i4 = 3;
        int i5 = 3;
        Integer i6 = 3;
        Integer i7 = 128;
        Integer i8 = 128;
        Log.d("fun_3_1", "i1==i2:" + (i1 == i2));
        Log.d("fun_3_1", "i1==i3:" + (i1 == i3));
        Log.d("fun_3_1", "i1==i4:" + (i1 == i4));
        Log.d("fun_3_1", "i1==i5:" + (i1 == i5));
        Log.d("fun_3_1", "i4==i6:" + (i4 == i6));
        Log.d("fun_3_1", "i7==i8:" + (i7 == i8));

    }


    void fun_2_2() {
        SoftReference<String> softReference = new SoftReference<String>(new String("hello"));
        System.out.println(softReference.get());
        System.gc();
        System.out.println(softReference.get());
    }

    void fun_1_1() {
        int a = 10;
        int b = 12;
        int c = 10;
        // JVM为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间——字符串实例池。
        String d = "www";
        String e = "www";
        String f = new String("eee");
        String g = new String("eee");
        Log.d("fun_1_1", String.valueOf(a == b));
        Log.d("fun_1_1", String.valueOf(a == c));
        Log.d("fun_1_1", String.valueOf(d == e));
        Log.d("fun_1_1", String.valueOf(f == g));


    }
}

class A {
    int a;
    int c = 10;
    private String b;

    void fun1() {
    }

    private void fun2() {
        final int d = 10;
        class C {
            void c() {
                int ee = d + 10;
                int ff = a;
            }
        }
    }

    public class B {
        void xx() {
            a = 10;
            b = "sss";
            fun1();
            fun2();
        }
    }
}

abstract class AB {

}

class DD extends AB {

}

class DataHolder<T> {
    public T getItem() {
        return item;
    }

    public void setItem(T item) {
        this.item = item;
        printInfo(item);
    }

    T item;

    public <E> void printInfo(E e) {
        System.out.println(e);
    }

}